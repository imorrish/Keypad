/*
 * vise_firmata.ino generated by FirmataBuilder
 * Fri Sep 29 2017 17:03:35 GMT-0400 (EDT)
 */
#include <Wire.h>
#include <Keypad.h>
#include <LiquidCrystal.h>
#include <ConfigurableFirmata.h>
LiquidCrystal lcd(10,11,2,3,4,5,6,7,8,9);
//#include <DigitalInputFirmata.h>
//DigitalInputFirmata digitalInput;

//#include <DigitalOutputFirmata.h>
//DigitalOutputFirmata digitalOutput;

//#include <AnalogInputFirmata.h>
//AnalogInputFirmata analogInput;

#include <SerialFirmata.h>
SerialFirmata serial;

#include <FirmataExt.h>
FirmataExt firmataExt;

#include <FirmataReporting.h>
FirmataReporting reporting;

#include <FirmataScheduler.h> 
FirmataScheduler scheduler; 

//LiquidCrystal lcd(10,11,2,3,4,5,6,7,8,9); // LCD Shield
//LiquidCrystal lcd(10, 11, 9, 8, 7, 6, 5, 4, 3, 2); // LCD Shield
// LCD init
#define BITSB 8            // number of bits per byte, used for code clarity
#define DATABITS 34          // what we must send to the chip in order to control the lights
#define STARTBIT 1           // value of the starting bit; 


const int clockPin = 13;        // connect Arduino pin 3 to clock pin (21) on the 5450
const int dataPin  = 12;        // connect Arduino pin 6 to data pin (22) on the 5450
const int delayTime = 60;       // delay between lights


// The following line just computes the number of bytes we will need in the ledArray to hold all of
// bits of data for the signal; it could be declared statically.
//
const int arrayLen = (int)((DATABITS-1)/BITSB) + 1; 

// This is the actual array that will hold the signal bits. This program, for the 5450/5451, will 
// need 5 bytes for a total of 40 bits.
//
byte ledArray[arrayLen];        // for this chip, length is 5 and that could hold 40 values  

typedef enum {             // this exists primarily for code clarity
OFF, ON
} ledState;

// Keypad setup
//
const byte ROWS = 8;
const byte COLS  = 5;
char keys[ROWS][COLS] = {
  {'1','9','h','p','x'},
  {'2','a','i','q','y'},
  {'3','b','j','r','A'},
  {'4','c','k','s','B'},
  {'5','d','l','t','C'},
  {'6','e','m','u','D'},
  {'7','f','n','v','E'},
  {'8','g','o','w','F'}
};
byte rowPins[ROWS] = {2,3,4,5,6,7,8,9};
byte colPins[COLS] = {14,15,16,17,18};

Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS );

void keypadEvent(KeypadEvent key){
    String echoMsg; 
    String action;    
    switch (keypad.getState()){
      case PRESSED:{
        action = "Down,";
        echoMsg = action+key;
        Firmata.sendString(echoMsg.c_str());
      }
    //case RELEASED:
    //   action = "Up,";
    //  echoMsg = action+key;
    //  Firmata.sendString(echoMsg.c_str());
        
    //case HOLD:
    //   action = "Hold,";
    //  echoMsg = action+key;
    //ebay
    //Firmata.sendString(echoMsg.c_str());
    }
}

void stringCallback(char *myString)
{
  String lcdString=String(myString);
  int Line1Index=lcdString.indexOf(',');
  int Line2Index=lcdString.indexOf(',', Line1Index+1); // more than one comma?

  String Line1 = lcdString.substring(0,Line1Index);
  String Line2 = lcdString.substring(Line1Index+1);
  // update led

  switch(Line1.toInt())
  {
  case 1:
    {
      setLight(Line2.toInt(), 1);
      sendDatabits();
      break;
      //delay(delayTime);
    }
    case 2:
    {
      setLight(Line2.toInt(), 0);
      sendDatabits();
      break;
      //delay(delayTime);
    }
    case 3:
    {
      toggleLight(Line2.toInt());
      sendDatabits();
      break;
      //delay(delayTime);
    }
    case 4:
    {
      dataOut();
      digitalWrite(A3, HIGH); 
      lcd.setCursor(0, 0);
      lcd.print("                    ");
      lcd.setCursor(0, 0);
      lcd.print(Line2);
      break;
    }
    case 5:
    {
      dataOut();
      digitalWrite(A3, HIGH); 
      lcd.setCursor(0, 1);
      lcd.print("                    ");
      lcd.setCursor(0, 1);
      lcd.print(Line2);
      break;
    }
    
  }
}
void dataOut()
{
  pinMode(2, OUTPUT); 
  pinMode(3, OUTPUT); 
  pinMode(4, OUTPUT); 
  pinMode(5, OUTPUT); 
  pinMode(6, OUTPUT); 
  pinMode(7, OUTPUT); 
  pinMode(8, OUTPUT); 
  pinMode(9, OUTPUT); 

}
void systemResetCallback()
{
  for (byte i = 0; i < TOTAL_PINS; i++) {
    if (IS_PIN_ANALOG(i)) {
      Firmata.setPinMode(i, ANALOG);
    } else if (IS_PIN_DIGITAL(i)) {
      Firmata.setPinMode(i, OUTPUT);
    }
  }
  firmataExt.reset();
}

void initTransport()
{
  // Uncomment to save a couple of seconds by disabling the startup blink sequence.
  Firmata.disableBlinkVersion();
  Firmata.begin(57600);
}

void initFirmata()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);

//  firmataExt.addFeature(digitalInput);
//  firmataExt.addFeature(digitalOutput);
//  firmataExt.addFeature(analogInput);
  firmataExt.addFeature(serial);
  firmataExt.addFeature(reporting);

  Firmata.attach(SYSTEM_RESET, systemResetCallback);
  Firmata.attach(STRING_DATA, stringCallback);
}

void setup()
{

  pinMode(A0,OUTPUT);
  pinMode(A1,OUTPUT);
  pinMode(A2,OUTPUT);
  pinMode(A3,OUTPUT);
  pinMode(A4,OUTPUT);
  pinMode(A5,OUTPUT);
  digitalWrite(A5, HIGH);

  //turn off keybord driver while writing data to LCD
  digitalWrite(A3, HIGH); 
  //set A1 and 2 low for LCD reclocking
  digitalWrite(A0, HIGH); 
  digitalWrite(A1, LOW); 
  digitalWrite(A2, LOW);   
    lcd.begin(20, 2);
    delay(500);
    //lcd.setCursor(1,1);
    //lcd.clear();
    lcd.print("Ian Morrish V-ISE");
    lcd.setCursor(0, 1);
    lcd.print("For 20x20 VideoHub");
    //delay(delayTime);
  //digitalWrite(A3, LOW); //keyboard library will enable data read mode

  initFirmata();
  initTransport();
  systemResetCallback();
  
    //set LED's
   pinMode(clockPin, OUTPUT); 
   pinMode(dataPin,  OUTPUT);  
  allOff();              // start with all lights off
  sendDatabits();
  for(int i = 1; i < DATABITS; i++) { // turn all lights on, in numerical order, starting with light 1
    setLight(i,ON);
    sendDatabits();
    delay(delayTime);
  }
  delay(delayTime);
  allOff();              // turn all lights off
  sendDatabits();
  delay(delayTime);

  setLight(34,ON);
  sendDatabits();
  delay(delayTime);
  keypad.addEventListener(keypadEvent);
}

void loop()
{
  //digitalInput.report();

  while(Firmata.available()) {
    Firmata.processInput();
  }

  //if (reporting.elapsed()) {
  //  analogInput.report();
  //}
  keypad.getKeys();
  //char key = keypad.getKey();
   //if (key) {
   //     Firmata.sendString("key pressed");
   //     Firmata.sendString(keys[key]);
        
   // }
   
  serial.update();
}

// Subroutine that sends all of the DATABITS to the chip. It begins by first sending the startbit, then it
// uses the Arduino shiftOut function to send the bits in each byte of the ledArray. I could have put the
// STARTBIT into the ledArray but decided that I liked it better outside of the array. Any time you want
// to turn lights on or off, this routine must be called after setting the appropriate bits in the ledArray.
//
void sendDatabits() {
  digitalWrite(clockPin, LOW);
  delay(2);
  digitalWrite(dataPin, STARTBIT);
  delay(2);
  digitalWrite(clockPin, HIGH);
  delay(5);
  digitalWrite(clockPin, LOW);
  delay(2);
  for(int i = 0; i < arrayLen; i++) {
    shiftOut(dataPin, clockPin, LSBFIRST, ledArray[i]);
  }
}

// Subroutine that takes a light (output pin) as a sole argument and sets the bit value for that pin
// to the opposite of its current setting (toggle).
//
void toggleLight(int pin) {
  byte arrayElem = int((pin-1)/BITSB);           // which element of the ledArray is pin in
  byte byteElem = (pin - (arrayElem * BITSB)) - 1;    // and which bit in that byte is the pin
  ledArray[arrayElem] ^= (1 << byteElem);         // toggle byteElem 
}

// Subroutine that takes a light (output pin) and an additional argument and sets the bit value
// for that pin appropriately
//
void setLight(int pin, byte val) {
  byte arrayElem = int((pin-1)/BITSB);           // which element of the ledArray is pin in
  byte byteElem = (pin - (arrayElem * BITSB)) - 1;    // and which bit in that byte is the pin
  //ledArray[arrayElem] |= (val << byteElem);        // zero vals require a two-step process, 
  //if(val == 0) {                      // first we set them to a one and then
  //  ledArray[arrayElem] ^= (1 << byteElem);        // toggle them
  //} 
  byte temp1 = ledArray[arrayElem];
  bitWrite(temp1,byteElem , val);
  ledArray[arrayElem] = temp1;
}


// Subroutine that turns all lights on. Because the STARTBIT is 1 or ON, we don't want to set any
// bits above 35 to ON, lest it be interpreted as the start of another set of databits. Better error
// checking would be to make sure that no bit > 35 was ever set to 1.
//
void allOn() {
  for(int i = 1; i < DATABITS; i++) {
   setLight(i, ON);
  }
}

// Subroutine that turns all lights off
//
void allOff() {
  for(int i = 0; i < arrayLen; i++) {
    ledArray[i] = 0;
  }
}
void demo(){
allOn();               // turn all lights on
sendDatabits();
delay(delayTime);

allOff();              // turn all lights off
sendDatabits();
delay(delayTime);

for(int i = 1; i < DATABITS; i++) { // turn all lights on, in numerical order, starting with light 1
 setLight(i,ON);
 sendDatabits();
 delay(delayTime);
}

for(int i = (DATABITS-1); i > 0; i--) {
 setLight(i,OFF);          // turn all lights off, in reverse numerical order, starting
 sendDatabits();          // with the last light
 delay(delayTime);
}

for(int i = (DATABITS-1); i > 0; i--) {
 setLight(i,ON);          // turn all lights on, in reverse numerical order, starting
 sendDatabits();          // with the last light
 delay(delayTime);
}

for(int i = 1; i < DATABITS; i++) { // turn all lights off, in numerical order, starting with light 1
 setLight(i,OFF);
 sendDatabits();
 delay(delayTime);
}

for(int i = 0; i < 3; i++) {     // flash the lights 3 times
 allOn();
 sendDatabits();
 allOff();
 sendDatabits();
 delay(500);
}
  
}
